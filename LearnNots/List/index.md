
## list

* list和tuple是Python内置的有序集合，一个可变，一个不可变 
   这意味着列表适用于需要中途添加元素的情形，而元组适用于出于某种考虑需要禁止修改序列的情形。
   几乎在所有情况下都可使用列表来代替元组。一种例外情况是将元组用作字典键,因为字典键是不允许修改的.

   索引来访问list中每一个位置的元素，索引是从0开始的;当索引超出了范围时，Python会报一个IndexError错误
   如果要取最后一个元素，除了计算索引位置外，还可以用-1做索引，直接获取最后一个元素
   如果一个list中一个元素也没有，就是一个空的list，它的长度为0
```py
>>> L = []
>>> len(L)
0
```
   因为tuple不可变，所以代码更安全,能用tuple代替list就尽量用tuple
    如果要定义一个空的tuple，可以写成()：
```py
# 定义空的tuple
>>> t = ()
>>> t
()

# 只有1个元素的tuple定义时必须加一个逗号,，来消除歧义
>>> t = (1,)
>>> t
(1,)
```


* enumerate 实现同时获取list的index和value
```py

'-'.join(c.upper() + c.lower() * i for i, c in enumerate(s))

```

*  给切片赋值
   切片是一项极其强大的功能，而能够给切片赋值让这项功能显得更加强大

      1.利用功能快速替换部分元素或者新增元素,可将切片替换为长度与其不同的序列
      ```py
      >>> name = list('Perl') 
      >>> name 
      ['P', 'e', 'r', 'l'] 
      >>> name[2:] = list('arc') 
      >>> name 
      ['P', 'e', 'a', 'r','c'] 
      ```
      2.切片赋值还可在不替换原有元素的情况下插入新元素
      ```py
      >>> numbers = [1, 5] 
      >>> numbers[1:1] = [2, 3, 4] 
      >>> numbers 
      [1, 2, 3, 4, 5] 
      ```
     3.删除切片，与del numbers[1:4]等效
     ```py
     >>> numbers 
      [1, 2, 3, 4, 5] 
      >>> numbers[1:4] = [] 
      >>> numbers 
      [1, 5] 
     ```
     4.清空列表的内容 和clear方法类似
     
     ```py
      >>> lst = [1, 2, 3] 
      >>> lst.clear() 
      >>> lst 
      [] 

      #这类似于切片赋值语句lst[:] = []
     ```
*  复制列表

   1.方法 copy 复制列表,常规复制只是将另一个名称关联到列表
   ```py
   >>> a = [1, 2, 3] 
   >>> b = a.copy() 
   >>> b[1] = 4 
   >>> a 
   [1, 2, 3] 
   ```
   2.使用 a[:]
   3.使用 list(a)

*  扩展列表
   1.用+号拼接 :不会改变原list
   ```py
   >>> a = [1, 2, 3] 
   >>> b = [4, 5, 6] 
   >>> a + b 
   [1, 2, 3, 4, 5, 6] 
   >>> a 
   [1, 2, 3] 
   ```
   2.extend方法 :会改变原list
   ```py
   >>> a = [1, 2, 3] 
   >>> b = [4, 5, 6] 
   >>> a.extend(b) 
   >>> a 
   [1, 2, 3, 4, 5, 6] 
   ```
   3.利用切分赋值 ：会改变原list，可读性不是很高
   ```py
   >>> a = [1, 2, 3] 
   >>> b = [4, 5, 6] 
   >>> a[len(a):] = b 
   >>> a 
   [1, 2, 3, 4, 5, 6] 
   ```

 * pop是唯一既修改列表又返回一个非None值的列表方法。使用pop可实现一种常见的数据结构——栈 （stack）后进先出（LIFO） 
 要创建先进先出（FIFO）的队列，可使用insert(0, ...)代替append。另外，也可继续使   用append，但用pop(0)替代pop()。一种更佳的解决方案是，使用模块collections中的 deque。

* sort 坑 sort会改变原来顺序但是不返回list副本，解决方案：
   1. 先copy副本在排序
   ```py
   >>> x = [4, 6, 2, 1, 7, 9] 
   >>> y = x.copy() 
   >>> y.sort() 
   >>> x 
   [4, 6, 2, 1, 7, 9] 
   >>> y 
   [1, 2, 4, 6, 7, 9] 
   ```
   2. 利用函数sorted 实际上，函数sorted可用于任何可迭代的对象。
   ```py
   >>> x = [4, 6, 2, 1, 7, 9] 
   >>> y = sorted(x) 
   >>> x 
   [4, 6, 2, 1, 7, 9] 
   >>> y 
   [1, 2, 4, 6, 7, 9] 
   ```

* sort 高级用法   
   实际上，函数sorted可用于任何可迭代的对象。实际上，函数sorted可用于任何可迭代的对象。
   参数key类似于参数cmp：你将其设置为一个用于排序的函数。然而， 不会直接使用这个函数来判断一个元素是否比另一个元素小，而是使用它来为每个元素创建一个键，再根据这些键对元素进行排序。 因此， 要根据长度对元素进行排序， 可将参数key设置为函数len
   ```py
   >>> x = ['aardvark', 'abalone', 'acme', 'add', 'aerate'] 
   >>> x.sort(key=len) 
   >>> x 
   ['add', 'acme', 'aerate', 'abalone', 'aardvark']
   ```
   函数sorted也接受参数key和reverse。在很多情况下，将参数key设置为一个自定义函数很有用。


## dict和set


### dict

* dict 中如果key 不存中，dict 就会报错（keyError）
    要避免key不存在的错误，有两种办法，
        一是通过in判断key是否存在
        二是通过dict提供的get()方法，如果key不存在，可以返回None，或者自己指定的value
        （同理这和list中索引取不存在索引就会报索引超界，这时候我们可以利用get（）方法）

* dict内部存放的顺序和key放入的顺序是没有关系的

* dict 和 list 比较

     * dict有以下几个特点 
        1. 查找和插入的速度极快，不会随着key的增加而变慢；
        2. 需要占用大量的内存，内存浪费多。
     * 而list相反：
        1. 查找和插入的时间随着元素的增加而增加；
        2. 占用空间小，浪费内存很少。

    所以，dict是用空间来换取时间的一种方法。dict的key必须是不可变对象，通过key计算位置的算法称为哈希算法（Hash）。

* dict的key设计很讲究，比如用元组作为key
* dict迭代的是key。如果要迭代value，可以用for value in d.values()，如果要同时迭代key和value，可以用for k, v in d.items()
* 对字典 d= {'a':24,'g':52,'i':12,'k':33}请按value值进行排序
   ```py
   >>> sorted(d.items(),key=lambda x:x[1])

   #请按alist中元素的age由大到小排序
   >>> alist = [{'name':'a','age':20},{'name':'b','age':30},{'name':'c','age':25}]
   >>> def sort_by_age(list1):
         return sorted(alist,key=lambda x:x['age'],reverse=True)
   ```

* 合并两个dic:
   ```py
   # 技巧 1
   >>> x={'a':1,'b':2}
   >>> y={'b':3,'c':4}
   >>> z={**x,**y}
   {'c':4,'a':1,'b':3}

   #技巧 2
   >>> x.update(y)
   >>> X
   {'a': 1, 'b': 3, 'c': 4}
   ```
* 使用del 删除

   x和y指向同一个列表
   ```py
   >>> x = ["Hello", "world"]
   >>> y = x
   >>> y[1] = "Python"
   >>> x
   ['Hello', 'Python']

   >>> del x
   >>> y
   ['Hello', 'Python']
   ```
   你可能认为通过删除x，也将删除y，但情况并非如此,x和y指向同一个列表，但删除x对y没有任何影响，因为你只删除名称x，而没有删除列表本身（值）。事实上，在Python中，根本就没有办法删除值，而且你也不需要这样做，因为对于你不再使用的值，Python解释器会立即将其删除。


* 使用exec 和eval 执行字符串及计算其结果
   函数exec主要用于动态地创建代码字符串，和sqlserver中类似，将动态执行代码；
   exec计算并返回字符串表示的表达式的结果,所以自己什么都不返回，因为它本身是条语句;
   请注意我们在执行exec函数的时候要添加一个字典参数，作为第二个参数
   ```py
   >>> from math import sqrt
   >>> scope = {}
   >>> exec('sqrt = 1', scope)
   >>> sqrt(4)
   2.0
   >>> scope['sqrt']
   1
   ```
   如你所见，可能带来破坏的代码并非覆盖函数sqrt。函数sqrt该怎样还怎样，而通过exec执行赋值语句创建的变量位于scope中。
* zip(seq1, seq2,...) 创建一个适合用于并行迭代的新序列

   函数zip可用于“缝合”任意数量的序列，并返回一个由元组组成的序列。需要指出的是，当序列的长度不同时，函数zip将在最短的序列用完后停止“缝合

 ### set   
 
 * set和dict类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在set中，没有重复的key。
 要创建一个set，需要提供一个list作为输入集合
 ``` py
>>> s = set([1, 2, 3])
>>> s
{1, 2, 3}

 ```
 场景使用：可以list去重

 set可以看成数学意义上的无序和无重复元素的集合，因此，两个set可以做数学意义上的交集、并集等操作
```py
>>> s1 = set([1, 2, 3])
>>> s2 = set([2, 3, 4])
>>> s1 & s2  #A,B 中相同元素
{2, 3}
>>> s1 | s2
{1, 2, 3, 4}
>>> s1 ^ s1  #A,B 中不同元素
{1, 4}
```





* list和tuple是Python内置的有序集合，一个可变，一个不可变 
   列表和元组的主要不同在于，列表是可以修改的，而元组不可以。这意味着列表适用于需要中途添加元素的情形，而元组适用于出于某种考虑需要禁止修改序列的情形。
   几乎在所有情况下都可使用列表来代替元组。一种例外情况是将元组用作字典键,因为字典键是不允许修改的.

   索引来访问list中每一个位置的元素，索引是从0开始的;当索引超出了范围时，Python会报一个IndexError错误
   如果要取最后一个元素，除了计算索引位置外，还可以用-1做索引，直接获取最后一个元素
   如果一个list中一个元素也没有，就是一个空的list，它的长度为0
```py
>>> L = []
>>> len(L)
0
```
   因为tuple不可变，所以代码更安全,能用tuple代替list就尽量用tuple
    如果要定义一个空的tuple，可以写成()：
```py
# 定义空的tuple
>>> t = ()
>>> t
()

# 只有1个元素的tuple定义时必须加一个逗号,，来消除歧义
>>> t = (1,)
>>> t
(1,)
```


* enumerate 实现同时获取list的index和value
```py

'-'.join(c.upper() + c.lower() * i for i, c in enumerate(s))

```

*  给切片赋值
   切片是一项极其强大的功能，而能够给切片赋值让这项功能显得更加强大
      1.利用功能快速替换部分元素或者新增元素,可将切片替换为长度与其不同的序列
      ```py
      >>> name = list('Perl') 
      >>> name 
      ['P', 'e', 'r', 'l'] 
      >>> name[2:] = list('arc') 
      >>> name 
      ['P', 'e', 'a', 'r','c'] 
      ```
      2.切片赋值还可在不替换原有元素的情况下插入新元素
      ```py
      >>> numbers = [1, 5] 
      >>> numbers[1:1] = [2, 3, 4] 
      >>> numbers 
      [1, 2, 3, 4, 5] 
      ```
     3.删除切片，与del numbers[1:4]等效
     ```py
     >>> numbers 
      [1, 2, 3, 4, 5] 
      >>> numbers[1:4] = [] 
      >>> numbers 
      [1, 5] 
     ```
     4.清空列表的内容 和clear方法类似
     ```py
      >>> lst = [1, 2, 3] 
      >>> lst.clear() 
      >>> lst 
      [] 

      #这类似于切片赋值语句lst[:] = []
     ```
*  复制列表
   1.方法 copy 复制列表,常规复制只是将另一个名称关联到列表
   ```py
   >>> a = [1, 2, 3] 
   >>> b = a.copy() 
   >>> b[1] = 4 
   >>> a 
   [1, 2, 3] 
   ```
   2.使用 a[:]
   3.使用 list(a)
*  扩展列表
   1.用+号拼接 :不会改变原list
   ```py
   >>> a = [1, 2, 3] 
   >>> b = [4, 5, 6] 
   >>> a + b 
   [1, 2, 3, 4, 5, 6] 
   >>> a 
   [1, 2, 3] 
   ```
   2.extend方法 :会改变原list
   ```py
   >>> a = [1, 2, 3] 
   >>> b = [4, 5, 6] 
   >>> a.extend(b) 
   >>> a 
   [1, 2, 3, 4, 5, 6] 
   ```
   3.利用切分赋值 ：会改变原list，可读性不是很高
   ```py
   >>> a = [1, 2, 3] 
   >>> b = [4, 5, 6] 
   >>> a[len(a):] = b 
   >>> a 
   [1, 2, 3, 4, 5, 6] 
   ```

 * pop是唯一既修改列表又返回一个非None值的列表方法。使用pop可实现一种常见的数据结构——栈 （stack）后进先出（LIFO） 
 要创建先进先出（FIFO）的队列，可使用insert(0, ...)代替append。另外，也可继续使   用append，但用pop(0)替代pop()。一种更佳的解决方案是，使用模块collections中的 deque。

* sort 坑 sort会改变原来顺序但是不返回list副本，解决方案：
   1. 先copy副本在排序
   ```py
   >>> x = [4, 6, 2, 1, 7, 9] 
   >>> y = x.copy() 
   >>> y.sort() 
   >>> x 
   [4, 6, 2, 1, 7, 9] 
   >>> y 
   [1, 2, 4, 6, 7, 9] 
   ```
   2. 利用函数sorted 实际上，函数sorted可用于任何可迭代的对象。
   ```py
   >>> x = [4, 6, 2, 1, 7, 9] 
   >>> y = sorted(x) 
   >>> x 
   [4, 6, 2, 1, 7, 9] 
   >>> y 
   [1, 2, 4, 6, 7, 9] 
   ```

* sort 高级用法   
   实际上，函数sorted可用于任何可迭代的对象。实际上，函数sorted可用于任何可迭代的对象。
   参数key类似于参数cmp：你将其设置为一个用于排序的函数。然而， 不会直接使用这个函数来判断一个元素是否比另一个元素小，而是使用它来为每个元素创建一个键，再根据这些键对元素进行排序。 因此， 要根据长度对元素进行排序， 可将参数key设置为函数len
   ```py
   >>> x = ['aardvark', 'abalone', 'acme', 'add', 'aerate'] 
   >>> x.sort(key=len) 
   >>> x 
   ['add', 'acme', 'aerate', 'abalone', 'aardvark']
   ```
   函数sorted也接受参数key和reverse。在很多情况下，将参数key设置为一个自定义函数很有用。